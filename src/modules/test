// src/modules/file.js
import { getCollection } from "./mongodb.js";
import { uuidv4, getFileExtension } from "../core.js";
import { getUserS3Config, uploadToS3, deleteFromS3 } from "./bucket.js";
import { maxFileSize } from "../constants.js";
import path from "node:path";
import fs from "node:fs";
import { promises as fsPromises } from "node:fs";
import { Logger } from "../gameObject.js";

let logger;

const getLogger = () => {
    if (!logger) {
        logger = new Logger();
    }
    return logger;
};

/**
 * Ajoute un fichier au système. Le téléverse sur S3 si configuré, sinon le sauvegarde localement.
 * @param {object} file - L'objet fichier provenant de express-formidable.
 * @param {object} user - L'objet utilisateur.
 * @returns {Promise<string>} Le GUID du fichier nouvellement ajouté.
 */
export const addFile = async (file, user) => {
    if (!file) {
        throw new Error("Aucun fichier fourni.");
    }
    if (file.size > maxFileSize) {
        throw new Error(`La taille du fichier dépasse la limite de ${maxFileSize / 1024 / 1024} Mo.`);
    }

    const guid = uuidv4();
    const extension = getFileExtension(file.name);
    const newFilename = `${guid}.${extension}`;
    const s3Config = await getUserS3Config(user);

    const fileData = {
        _id: guid,
        guid: guid,
        originalFilename: file.name,
        size: file.size,
        mimetype: file.type,
        createdAt: new Date(),
        user: user.username // Bonne pratique : garder une trace de l'uploader
    };

    if (s3Config && s3Config.bucketName) { // Correction: bucketName au lieu de bucket
        try {
            // Correction: Appel manquant à la fonction de téléversement
            await uploadToS3(s3Config, file.path, newFilename);

            fileData.storage = 's3';
            fileData.filename = newFilename; // Le nom sur S3
            getLogger().log(`Fichier ${newFilename} téléversé sur le bucket S3 ${s3Config.bucketName}.`);
        } catch (error) {
            getLogger().log(`Le téléversement S3 a échoué pour ${file.name}: ${error.message}`, 'error');
            throw new Error("Le téléversement S3 a échoué.");
        } finally {
            // Nettoyer le fichier temporaire uploadé par express-formidable
            await fsPromises.unlink(file.path).catch(e => getLogger().log(`Échec de la suppression du fichier temporaire ${file.path}: ${e.message}`, 'error'));
        }
    } else {
        // Sauvegarde locale
        const uploadDir = path.join(process.cwd(), "uploads");
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        const newPath = path.join(uploadDir, newFilename);

        try {
            // express-formidable place déjà le fichier dans un répertoire temporaire. Nous n'avons qu'éplacer.
            await fsPromises.rename(file.path, newPath);
            fileData.storage = 'local';
            fileData.filename = newFilename; // Le nom dans le dossier uploads
            fileData.path = newPath; // Le chemin complet pour les fichiers locaux
            getLogger().log(`Fichier ${newFilename} sauvegardé localement dans ${newPath}.`);
        } catch (error) {
            getLogger().log(`Le déplacement du fichier local a échoué pour ${file.name}: ${error.message}`, 'error');
            // Essayer de nettoyer le fichier temporaire même si le renommage échoue
            await fsPromises.unlink(file.path).catch(e => getLogger().log(`Échec de la suppression du fichier temporaire ${file.path}: ${e.message}`, 'error'));
            throw new Error("Le stockage du fichier local a échoué.");
        }
    }

    const filesCollection = await getCollection("files");
    await filesCollection.insertOne(fileData);

    return guid;
};

/**
 * Récupère les métadonnées d'un fichier depuis la base de données.
 * @param {string} guid - Le GUID du fichier.
 * @returns {Promise<object|null>} L'objet de métadonnées du fichier ou null si non trouvé.
 */
export const getFile = async (guid) => {
    const filesCollection = await getCollection("files");
    return await filesCollection.findOne({ guid });
};

/**
 * Supprime un fichier du système (S3 ou local) et son enregistrement en base de données.
 * @param {string} guid - Le GUID du fichier à supprimer.
 * @param {object} user - L'objet utilisateur.
 * @returns {Promise<void>}
 */
export const deleteFile = async (guid, user) => {
    const fileData = await getFile(guid);
    if (!fileData) {
        getLogger().log(`Tentative de suppression d'un fichier inexistant avec le GUID : ${guid}`, 'warn');
        return;
    }

    if (fileData.storage === 's3') {
        const s3Config = await getUserS3Config(user);
        if (s3Config && s3Config.bucketName) { // Correction: bucketName au lieu de bucket
            try {
                await deleteFromS3(s3Config, fileData.filename);
                getLogger().log(`Fichier ${fileData.filename} supprimé du bucket S3 ${s3Config.bucketName}.`);
            } catch (error) {
                getLogger().log(`La suppression S3 a échoué pour ${fileData.filename}: ${error.message}`, 'error');
                throw new Error("La suppression S3 a échoué.");
            }
        } else {
             getLogger().log(`Configuration S3 non trouvée pour l'utilisateur, impossible de supprimer le fichier ${fileData.filename} de S3.`, 'error');
             throw new Error("Configuration S3 non trouvée, impossible de supprimer le fichier.");
        }
    } else if (fileData.storage === 'local') {
        try {
            if (fileData.path && fs.existsSync(fileData.path)) {
                await fsPromises.unlink(fileData.path);
                getLogger().log(`Fichier local ${fileData.path} supprimé.`);
            } else {
                getLogger().log(`Fichier local non trouvé au chemin ${fileData.path}, mais suppression de l'enregistrement en BDD.`, 'warn');
            }
        } catch (error) {
            getLogger().log(`La suppression du fichier local a échoué pour ${fileData.path}: ${error.message}`, 'error');
            throw new Error("La suppression du fichier local a échoué.");
        }
    }

    const filesCollection = await getCollection("files");
    await filesCollection.deleteOne({ guid });
    getLogger().log(`Enregistrement du fichier ${guid} supprimé de la base de données.`);
};